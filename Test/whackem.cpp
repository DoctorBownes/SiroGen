#include "whackem.h"

const int width = 8;
const int height = 8;
const int TileSize = 16;


int testlevel[height][width]{
{ 1,1,1,1,1,1,1,1 },
{ 1,0,1,0,0,0,0,1 },
{ 1,1,1,0,0,0,0,1 },
{ 1,0,1,0,0,0,0,1 },
{ 1,0,0,0,0,0,0,1 },
{ 1,0,0,0,0,0,0,1 },
{ 1,0,0,0,1,0,0,1 },
{ 1,1,1,1,1,1,1,1 },
};

void setPos(Entity* entity, int x, int y)
{
	entity->transform->position->x = x * TileSize;
	entity->transform->position->y = -y * TileSize;
}

Whackem::Whackem() : Scene()
{
	this->GetMainCamera()->SetZoom(10);
	this->joey = new Player();
	setPos(joey, 3, 2);

	static char WallCanvas[]
	{
		0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
		0xe,0xf,0xf,0xf,0xf,0xf,0xf,0x1,0xe,0xf,0xf,0xf,0xf,0xf,0xf,0x1,
		0xe,0xf,0xf,0xf,0xf,0xf,0xf,0x1,0xe,0xf,0xf,0xf,0xf,0xf,0xf,0x1,
		0xe,0xe,0xe,0xe,0xe,0xe,0xe,0x1,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0x1,
		0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
		0xf,0xf,0xf,0x1,0xe,0xf,0xf,0xf,0xf,0xf,0xf,0x1,0xe,0xf,0xf,0xf,
		0xf,0xf,0xf,0x1,0xe,0xf,0xf,0xf,0xf,0xf,0xf,0x1,0xe,0xf,0xf,0xf,
		0xe,0xe,0xe,0x1,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0x1,0xe,0xe,0xe,0xe,
		0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
		0xe,0xf,0xf,0xf,0xf,0xf,0xf,0x1,0xe,0xf,0xf,0xf,0xf,0xf,0xf,0x1,
		0xe,0xf,0xf,0xf,0xf,0xf,0xf,0x1,0xe,0xf,0xf,0xf,0xf,0xf,0xf,0x1,
		0xe,0xe,0xe,0xe,0xe,0xe,0xe,0x1,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0x1,
		0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
		0xf,0xf,0xf,0x1,0xe,0xf,0xf,0xf,0xf,0xf,0xf,0x1,0xe,0xf,0xf,0xf,
		0xf,0xf,0xf,0x1,0xe,0xf,0xf,0xf,0xf,0xf,0xf,0x1,0xe,0xf,0xf,0xf,
		0xe,0xe,0xe,0x1,0xe,0xe,0xe,0xe,0xe,0xe,0xe,0x1,0xe,0xe,0xe,0xe,
	};
	static char GroundCanvas[]
	{
		0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
		0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
		0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
		0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
		0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0xf,0xf,0x1,0x1,0x1,0x1,0x1,0x1,
		0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0xf,0xf,0x1,0x1,0x1,0x1,0x1,0x1,
		0xf,0xf,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
		0xf,0xf,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
		0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
		0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
		0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
		0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
		0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0xf,0xf,0x1,0x1,0x1,
		0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0xf,0xf,0x1,0x1,0x1,
		0x1,0x1,0x1,0xf,0xf,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
		0x1,0x1,0x1,0xf,0xf,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
	};

	char* canvasarray[]
	{
		GroundCanvas, WallCanvas,
	};
	
	for (int y = 0; y < height; y++)
	{
		for (int x = 0; x < width; x++)
		{
			Entity* tempEntity = new Entity();
			tempEntity->RemoveComponent<Update>();
			tempEntity->AddComponent<Sprite>()->SetSprite(canvasarray[testlevel[y][x]], 16,16);
			setPos(tempEntity, x, y);
			Addchild(tempEntity);
		}
	}
	this->Addchild(joey);
	//this->don = new Gangster();
	//this->Addchild(don);
	//this->dontoo = new Gangster();
	//don->Addchild(dontoo);
	//this->donthree = new Gangster();
	//dontoo->Addchild(donthree);
	//dontoo->transform->position->x = 10;
	//donthree->transform->position->x = 20;
	//don->transform->position->x = -40;
	//bkgdcolor = 2;

	//for (int i = 0; i < 6; i++)
	//{
	//	this->don = new Gangster();
	//	mob.push_back(don);
	//	mob[i]->target = joey;
	//	mob[i]->SetColor((i + 1) * 2);
	//	Addchild(mob[i]);
	//}
	//mob[0]->transform->position->x = -48;
	//mob[1]->transform->position->x = -32;
	//mob[2]->transform->position->x = -16;
	//mob[3]->transform->position->x = 16;
	//mob[4]->transform->position->x = 32;
	//mob[5]->transform->position->x = 48;
	//AddSceneText("SiroGen", 700, 800, 10);
}

bool isWallat(float x, float y)
{
	// can't divide by zero, solution required. Possibly if statement
	int mapGridX = std::ceilf(x / TileSize);
	int mapGridY = std::ceilf(-y / TileSize);

	int mapGridX2 = std::floorf(x / TileSize);
	int mapGridY2 = std::floorf(-y / TileSize);
	
	if (testlevel[mapGridY][mapGridX] == 1 || testlevel[mapGridY2][mapGridX2] == 1)
		return true;
	else
		return false;
}

void Whackem::update(float deltaTime)
{
	if (isWallat(joey->transform->position->x, joey->transform->position->y))
	{
		std::cout << "Wall here \n";
	}
	//deltaTime = 0.0f;
	//for (int i = 0; i < mob.size(); i++)
	//{
	//if (don != nullptr)
	//{
	//	if (don->GetComponent<Collider>()->isColliding(joey) || donthree->GetComponent<Collider>()->isColliding(joey) || dontoo->GetComponent<Collider>()->isColliding(joey))
	//	{
	//		std::cout << "Colliding!" << std::endl;
	//		this->Removechild(don);
	//		don = nullptr;
	//	}
	//}
		//mob[i]->GetComponent<Animation>()->PlayAnimation(mob[i]->drawAnim);
	//}
		//if (GetInput()->KeyPressed(KeyCode::R))
		//{
		//	this->Addchild(don);
		//}
	if (GetInput()->KeyPressed(KeyCode::Escape))
	{
		isRunning = false;
	}
	GetMainCamera()->position.x = joey->transform->position->x;
	GetMainCamera()->position.y = joey->transform->position->y;
}